20-09-03 C Study (Day 5)
=====
교제 : 윤성우의 열혈 C 프로그래밍  

chapter 4 ~ 5
<hr>

## <컴퓨터가 데이터를 표현하는 방식>

##### 컴퓨터는 2진수를 기반으로 데이터를 표현하고 연산한다.

| 진법 | 표현(예시) |표기    | 표현 범위| 
|------|------------|--------|----------| 
|10진법| 47         |47      |0~9| 
|2진법 |101111      |0b101111|0~1|
|16진법|2F          |0x2F    |0~15 (0 ~ F)|

16진수 표현법을 많이 접하게 되는데 2진수 표현은 길이가 길어져 표현하기에도, 한눈에 파악하기에 쉽지 않다.  
그러기에 2진수 네 개를 16진수 하나로 표현 가능하기에 16진수 사용에 익숙해지면 좋다.  

### 데이터의 표현단위인 비트(Bit)와 바이트(Byte)

__비트__ : 컴퓨터가 표현하는 최소단위인 2진수 값 하나를 저장할 수 있는 메모리의 크기
- 8bit = 1byte

## <정수와 실수의 표현방식>

앞서 자료형에는 정수형과 실수형의 자료형이 있다고 배웠다.  
실제로 그들이 어떤 방식으로 표현되는지 알아보자.  

### 정수의 표현방식

- 정수 가장 왼쪽의 비트는 '부호비트'이다.

정수에는 기본적으로 부호가 존재한다. 이에 가장 첫번째 비트는 부호비트로 정의하며 이 비트를 MSB(Most Significant Bit)라고 한다.  
기본적으로 양수는 0 음수에는 1을 저장한다.

- 음의 정수를 표현할 때에는 2의 보수를 취한다.

절댓값이 같은 음의 정수와 양의 정수를 비트단위로 덧셈하였을 때 결과 값이 0이 나오게끔 설정한다.

### 실수의 표현방식

- __부동 소수점 표현__  
2바이트를 기준으로 표현의 예를 들면   
상위 1바이트 중 1비트는 부호를 표현 나머지는 가수부  
하위 1바이트는 지수부를 표현하게 된다.
```
$$ \pm (1.m)\times 2^(e-127) $$
```
- __실수에는 오차가 존재__  
컴퓨터의 실수표현은 근사치를 표현할 뿐이다.  
이에 따른 오차를 '부동 소수점 오차'라고 한다.
<hr>

## <C언어가 재공하는 기본 자료형>

### 정수형

| 자료형 | 크기 | 표현 범위| 
|------  |------|----------| 
|char    |1byte |-128 ~ +127| 
|short   |2byte |-32,768 ~ 32,767|
|int     |4byte |-2,147,483,648 ~ +2,147,483,647|
|long    |4byte |-2,147,483,648 ~ +2,147,483,647|
|longlong|8byte |약 -900경 ~ +900경|

### 실수형 

| 자료형    | 크기     |소수점 이하 정밀도|
|-----------|----------|------|
|float      |4byte     |6자리 |
|double     |8byte     |15자리|
|long double|8byte 이상|18자리|

+ 자료형 앞에 unsigned를 붙이면 0과 양의 정수만 표현하게 설정가능하다.

## <문자의 표현방식>

- __문자는 아스키(ASCII)코드로 표현된다__

|아스키 코드|아스키 코드 값|
|--|--|
|A|65|
|B|66|
|`|96|
|~|126|

자세한 사항은 링크를 참조하라 ->
[아스키 코드 표](https://ko.wikipedia.org/wiki/ASCII)  

### 프로그램상의 문자표현

```c
int main(void){
	char ch1 = 'A';	// 작은 따옴표로 감싸서 표현한다.
	char ch2 = 66;	// 문자 B의 아스키 코드 값 66
	. . . .
}
```

## <상수에 대한 이해>

프로그램 상에 숫자를 표현하면 기본적으로 정수는 int형 실수는 double형으로 설정된다.  
  
__예시 코드__
```c
#include <stdio.h>

int main(void){
	printf("literal int size: %d \n", sizeof(3));
	printf("literal double size: %d \n", sizeof(3.14));
	printf("literal char size: %d \n", sizeof('A'));
	return 0;
}
```
__실행 결과__

```
literal int size: 4 
literal double size: 8 
literal char size: 4 
```
여기서 주목할 건 'A'의 값 65가 4byte인 int형에 담겼다는 사실이다.

## <자료형의 변환>

자료형 변환에는 2가지가 있다.  
- 자동 형 변환
- 강제 형 변환

### 자동 형 변환

컴파일러가 알아서 변환해주는 형 변환에 해당한다.

#### 1. 대입연산의 전달과정에서 발생하는 자동 형 변환 
```
double num1 = 245;	// int형 정수 245를 double형으로 자동 형 변환  
int num2 = 3.1415;	// double형 실수 3.1415를 int형으로 자동 형 변환
```
알 수 있는 사실은 큰 데이터 형에서 작은 데이터 형으로 변환시에 데이터 손실은 불가피하다는 것이다.  

#### 2. 정수의 승격에 의한 자동 형 변환

일반적으로 CPU가 처리하기에 연산자는 int형 연산의 속도가 다른 자료형의 연산속도에 비해 동일하거나 빠르다. 
```
short num1 = 15, num2 = 25;  
short num3 = num1 + num2;  
```
num1과 num2가 int형으로 변환된 후에 연산 후 short형으로 변환되어 num3에 저장된다.

#### 3. 피연산자의 자료형 불일치로 발생하는 자동 형 변환

연산은 피연산자간의 자료형이 일치할 때 가능하다.  
이에 피 연산자간에 자료형이 일치하지 않을 때 데이터 손실이 적은쪽으로 자료형 변환이 일어난다.

자료형의 크기순서는 다음과 같다.  
int < long < long long < float < double < long double  

### 강제 형 변환

프로그래머가 강제로 형 변환을 명령하는 경우이다.  
방법은 __피연산자 앞에 (자료형)을 붙여주면 된다.__

```
int num1=3, num2=4;
double divResult;
divResult = (double)num1 / num2; 
```
num1이 강제 형 변환되고 num2는 자동형 변환 3번 규칙을 따라 double로 형 변환 된다.