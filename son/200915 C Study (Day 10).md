20-09-15 C Study (Day 10)
=====
교제 : 윤성우의 열혈 C 프로그래밍

chapter 12 ~ 13

<hr>

## <<포인터>>

### 포인터 변수

주소 값의 저장을 목적으로 선언되는 포인터 변수이다.

#### 주소 값?

컴퓨터의 메모리에는 값이 저장된 위치를 알기 위한 주소 값이 존재한다.  
저장된 변수에 접근을 하기 위한 방법이 이 주소 값을 통해 접근이 가능한 것이다.  
  
주소 값은 컴퓨터의 비트 시스템에 의해 결정되는데 
32bit 컴퓨터는 4byte, 64bit 컴퓨터는 8byte의 주소 값을 갖게 된다.

```c
int* pnum;
```

위와같이 포인터 변수를 선언하며 포인터 변수에도 타입이 존재한다.  
그 이유는 주소 값만 가지고는 접근한 위치의 값의 코드만으로는
이 값이 어떤 type으로 되어 있는지 판단을 할 수 없기에 포인터에 형(type)이 존재한다.

### & 연산자와 * 연산자

연산자 & : 변수 앞에 붙어 해당 변수의 주소 값을 반환
  
연산자 \* : 포인터형 변수 앞에 붙어 해당 포인터가 가리키는 주소의 메모리에 접근
  
__예시)__
```c 
int num = 10;
int* pnum;

pnum = &num;	// pnum이 num의 주소를 가리키게 함
*pnum = 20;		// num = 20와 동일한 문장
```

### 널 포인터

포인터는 메모리에 직접 접근을 가능하게 하는 매우 유용한 기능이나 매우 위험성이 높다.  
`int* pnum = 25;` 이 문장을 생각 해보자 25번지 주소에 들어있는 값은 우린 모른다  
그러나 \*연산을 통하여 접근하면 매우 위험한 상황이 벌어진다.  
`int* pnum1 = 0;` `int* pnum2 = NULL;` 이 두 문장은 같은 의미를 지닌다 NULL이란 아무 것도 가리키지 않는 상태를 말하여 '0'값으로 초기화하는 것 또한 같은 의미이다.

<hr>

## <<포인터와 배열>>

### 배열의 의미

배열의 이름은 값을 변경할 수 없는 상수 포인터이며 배열의 요소간의 주소 값의 차이는 배열의 type의 크기와 같다.  

### 포인터 연산

포인터도 증감연산(++,--)연산이 가능하다. 그러면 어떻게 동작하는가?  
```c
int* ptr1 = 0x0010;
double* ptr2 = 0x0010;

ptr1++;
ptr2--;
``` 
포인터에서의 증감연산은 해당 포인터 변수의 type의 크기 만큼 증감연산이 적용 된다.  
즉 ptr1의 값은 int의 크기인 4만큼 증가하여 0x0014를 가리키고 ptr2의 값은 double의 크기인 8만큼 감소하여 0x0002를 가리키게 된다.  

### arr[i] == *(arr+i)

배열의 이름은 배열의 첫번째 요소의 주소 값과 같다.  
위의 포인터 연산을 응용해 보면 배열에 +i를 해주면 i번째 요소의 주소 값이 반환된다는 것을 알 수 있다.  

### 상수 형태의 문자열 

`char str1[] = "My String";` `char* str2 = "Your String";`  
위의 배열로 선언한 str1은 "My String"의 첫번째 요소 'M'을 가리키게 되고 배열의 정의대로 가리키는 위치는 변경할 수 없다.  
그러나 배열 내부의 문자열은 변경이 가능하여  'M'대신에 다른 문자를 저장 할 수 있다.  
포인터형으로 선언한 str2는 "Your String"이라는 자동으로 할당된 문자열의 첫번째 요소 'Y'를 가리키게 되고 str2은 얼마든지 다른 주소를 가리킬 수 있다.  
그러나 자동으로 할당된 "Your String"의 문자열 변경은 할 수 없다.  

### 포인터 배열

배열의 요소에 주소 값을 담을 수 있는 배열을 의미한다.  

```c
char* ptrArr[3] = {"Simple", "Pointer", "Array"};
``` 
위와 같이 배열 요소에 문자열을 담을 수 있다.

