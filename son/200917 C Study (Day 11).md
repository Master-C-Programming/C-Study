20-09-17 C Study (Day 11)
=====
교제 : 윤성우의 열혈 C 프로그래밍

chapter 14

<hr>

## 포인터와 함수

### 함수 인자의 전달 방식

함수의 인자로 값이 전달되는 방식은 기본적으로 '복사'이다.  
값을 1증가 시켜주는 함수를 만든다고 하자  

```c
int addAge1 (int num) {
	return num+1;
}
int main (void) {
	int age = 23;
	addAge1(age);
	prnitf("%d", age);
}
```

과연 제대로 age의 값이 증가 되었을까?  
출력결과를 확인하면 age는 초기화된 값 그대로 출력될 것이다.  
  
기본적으로 age는 지역변수인 것도 있지만 addAge함수에는 age의 값 23이 그대로 복사해 가져간 후 그값을 1 증가시켰을 뿐이지
실제 age의 값에는 아무 영향을 주지 않는다.  

```c
void addAge2 (int* num) {
	*num++;
}
imt main (void) {
	int age = 23;
	addAge2(&age);
	prnitf("%d", age);
}
```

이렇게 age의 주소 값을 넘겨주면 해당 블럭 내부가 아니라도 age에 접근 가능할 뿐더러 age의 실제 값을 조작할 수 있다.  

### 함수 인자로의 배열 전달

배열의 기본 원리는 포인터와 같다는 것을 앞에서 배웠다.  
매개변수로 포인터형을 선언하면 배열의 주소 값을 전달 받을 수 있으며 이 매개변수가 배열임을 알아차리기 쉽게 표기 가능하다.
```
int arrFunc (int arr[]) { . . . }
```
여기서 매개변수 `int arr[]`는 모습만 배열이지 `int* arr`와 완전하게 같은 의미를 가진다.  

### Call-by-value vs. Call-by-reference

- Call-by-value : 함수의 매개변수가 type형으로 선언되어 값을 전달 받는 것 
- Call-by-reference : 함수의 매개변수가 포인터형으로 선언되어 주소 값을 전달 받는 것

#### scanf 함수 호출시 &를 붙이는 이유

scanf 함수호출이 완료되면 그 값에는 입력장치로 입력받은 값이 채워진다.  
이를 통해 주소 값을 전달하지 않으면 위의 `addAge1`과 같은 오류를 범할 수 있다.

### 포인터 대상의 const 선언

일반 변수 대상의 const 선언은 해당 변수를 상수화 시켜 값의 변화를 할 수 없게 막는다.  
그렇다면 포인터에서는 어떻게 동작할까?  

```c
int num = 20;
const int* ptr = &num;
*ptr = 30;	// 컴파일 에러
num = 40;	// 컴파일 성공
```

이렇듯 const 선언이 문장 맨 앞에 오면 해당 포인터 변수로 * 연산을 통해 값의 변결을 막는다.  

```c
int num1 = 20;
int num2 = 30;
int* const ptr = &num1;
ptr = &num2;	// 컴파일 에러
*ptr = 40;		// 컴파일 성공
```

const 선언이 포인터 변수명 앞에 오면 ptr이 처음 초기화된 주소 값밖에 가리키지 못하게 된다.

#### const 선언의 의미

프로그램 개발은 혼자하는 것이 아니다.  
누군가와 같이하다보면 의도치 않은 실수들을 범하게 되고 서로 코드에 영향을 줄 수 있다.  
이렇기에 우리는 안전장치를 마련하여야 하는데 이 const선언이 안전장치 역할을 수행한다.
