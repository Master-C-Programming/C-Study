포인터 : 주소 값의 저장이 목적
	주소값은 컴퓨터 bit따라 다름
	ex) 32bit 컴퓨터는 4byte / 64bit 컴퓨터는 8byte 짜리 주소값이 저장된다.
	   sizeof()을 사용하여 확인 가능

int num : int형 변수
int* num : int형 포인터 변수

※ int형 포인터는 int형 변수의 주소 값을 가리켜야 됨
   *ptr 연산자를 사용해 메모리에 접근 할 떄 저장되는 값의 형태를 일치 시켜야 자료의 왜곡 없이 저장된다.

<* 와 & 비교>
*는 포인터 변수 앞에 쓰이고
기능은 포인터 변수에 들어있는 주소 값이 가리키는 공간의 값을 의미
 비유하면 논리회로 때 hex 컴퓨터 A M D 연산자 중에 M과 비슷하게 작용함

&는 해당 변수의 주소 값이 반환됨
ex) 
int num = 40;
int ptr1 =0;
int* ptr2= NULL; // 널 값은 아무것도 가리키지 않는 상태를 의미
ptr = num 
ptr = &num // num의 주소값을 ptr에 넣음 ( ptr은 num을 가리키게 됨)


((포인터와 배열))

배열은 포인터와 상당히 비슷하다

int arr[10];
이때 arr에 arr[0]의 주소 값이 저장된고 이후 arr[1]은 arr의 주소 값에 type의 크기(여기서는 int니까 4byte)만큼 더하여
arr 의 주소값이 0x002 이면 arr[1]은 0x006이 된다.

포인터 연산)
int* ptr = arr;
ptr = ptr +1; 은 어떻게 작용하는가?
위에서 말했던 것 처럼 ptr의 값에 int형의 크기만큼 증가하게 된다(+1이지만 사실 +1*(sizeof(int)) 인셈이다).

arr[i] == *(arr+i) 이 둘은 똑같은 의미를 가진다.

배열은 포인터와 비슷하나 상수형태로 사용된다.

int* ptr은 ptr내의 값을 변경 가능하나
int arr[]에서 arr의 주소 값은 변경 불가능



