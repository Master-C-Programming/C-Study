# 0915 C-Study
사용 도서 : C 기초 플러스 6판 (성안당)

###### Chapter 04. 문자열과 입출력 포맷 (page 148 ~ 163)
###### Chapter 04. 문자열과 입출력 포맷 (page 168 ~ 184)
<hr>

### `printf()` 함수
* __`printf()`의 return값__<br>
    `printf()`함수는 자신이 출력한 문자의 수를 return한다. 출력에 에러가 발생한 경우, 하나의 음수를 return한다.
* __긴 문자열의 출력__<br>
    `printf()`로 출력할 문자열이 길어지면서 라인을 분리하고 싶은 욕구가 생길 때가 있다. 그럴 땐, 라인 분리가 요소들 사이에서만 이루어진다면 상관 없다. 만약 하나의 문자열을 나눠야 한다면, 다음 3가지 방법이 있다.
        1. 여러개의 `printf()`를 사용한다.
        2. `\`를 사용한다. `\`로 문자열을 나눴다면 다음 라인은 첫칸부터 시작해야 한다. 만약 들여쓰기를 한다면, 그 들여쓰기도 문자열에 포함된다.
        3. 큰따옴표로 묶인 문자열 상수를 여러개 사용하는 것이다. 문자열 상수 사이에는 화이트스페이스만 와야 한다.
    

### `scanf()` 함수
`scanf()`는 `printf()`의 역함수라고 할 수 있다. 즉, 입력받은 문자열의 문자들을 알맞는 수치값으로 변환하는 것이 `scanf()`의 역할이다. <br>
`printf()`에서는 `float`와 `double`에 __conversion specifier__ 로 모두 `%f`를 사용했지만, `scanf()`에서는 `double`형에 `%lf`를 요구한다.
* __`scanf()`가 바라보는 입력__<br>
    - `scanf()`는 __conversion specifier__ 와 일치하지 않는 데이터형을 만나 중단되면, 해당 문자를 입력에 되돌려 준다. 즉, 새로운 `scanf()`가 나타난다면 해당 문자부터 입력을 받는다. 
    - C에서는 `scanf()`가 입력 받기를 실패했을 때, `scanf()`가 읽기를 멈추게끔 한다. 
    - `%s`로 문자열을 입력받을 때, `scanf()`는 화이트스페이스가 나오지 않을 때까지 입력을 무시하다가, 문자가 나오면 입력을 받기 시작하고, 다시 화이트스페이스를 만나면 읽기를 멈춘다. 한마디로 한 단어만 읽을 수 있다. 마지막으로 문자열 마지막에 `\0`을 추가한다.
* __포맷 문자열에 들어있는 일반문자__<br>
    포맷 문자열 안에서 스페이스를 제외한 일반문자들은 입력하는 문자열과 정확히 일치해야 한다. `%d`뒤에 바로 `,`가 왔다면, 입력할 때에도 정수 뒤에 바로 `,`를 입력해야 한다. 
* __`scanf()`의 return값__<br>
    `scanf()`는 성공적으로 읽은 항목의 수를 return한다. 읽은 항목이 없다면 __0__ 을, 파일의 끝이라고 알려진 어떤 조건을 만나면 `EOF`를 return한다.

### `printf()`, `scanf()`에서의 `*` 변경자
* __`printf()`에서의 사용__<br>
    `%*.*f`같은 __conversion specifier__ 를 사용했다고 가정하자. 사용자는 `*`에 해당하는 수치값을 `printf()` 문자열 요소 뒤에 포함해야 한다.
* __`scanf()`에서의 사용__<br>
    `%*d`와 같이 사용한다고 가정하자. `scanf()`에서는 `*`가 붙은 입력들을 건너뛴다.

### *lvalue*와 *rvalue*
* __*lvalue*__<br>
    C 초창기 때 __*lvalue*__ 의 정의는 다음과 같다. 
    1. 대입 연산자 왼편에서 사용한다.
    2. 메모리 주소를 참조한다.
    <br>
    그 후 `const`가 추가되면서, 2번 정의는 만족하지만 1번 정의는 만족하지 못하는 경우가 발생했다. 이에 C는 "변경할 수 있는 좌변값(modifiable value)"라는 용어를 추가했다.
    <br>
    현재 표준은 "객체 탐지값(object locator value)"라는 용어를 제안한다. 

* __*rvalue*__<br>
    __*rvalue*__ 는 `modifiable value`에 대입할 수 있는 수량을 지칭한다. 

### 우선순위와 계산 순서
다음 식을 보자.
> y = 6 * 12 + 5 * 20
얼핏보면 `6 * 12`가 먼저 계산되고, `5 * 20`이 계산된 다음 `72 + 100`의 연산이 수행될 것 같다. 그러나 C는 `6 * 12`와 `5 * 20` 연산의 우선순위 설정을 컴파일러에게 위임했다. 그 이유는 하드웨어에 따라 더 효율적인 방법을 컴파일러가 선택할 수 있게 하기 위해서다. 
