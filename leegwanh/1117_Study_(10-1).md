# 1117 C-Study
사용 도서 : C 기초 플러스 6판 (성안당)

###### Chapter 10. 배열과 포인터 (page 474 ~ 491)
<hr>

### 포인터 매개변수

```c
int sum1(int ar[], int n);   // 1
int sum2(int *start, int *end)  // 2

int main(void)
{
    int ar[n] = {...};
    ...
    int n1 = sum1(ar, n);
    int n2 = sum2(ar, ar + n)
}
```

__1번__ 형식은 배열의 시작 위치를 포인터로 넘겨주고, 배열의 크기를 나타내는 변수를 넘겨준다. __2번__ 형식은 배열의 시작과 끝 포인터를 넘겨준다. __2번__ 에서 배열의 끝을 가리키는 포인터는 배열의 마지막 원소 바로 다음을 가리킨다. __*C 에서는 배열을 위한 공간을 할당할 때 배열의 끝 바로 다음 위치를 가리키는 포인터(past-the-end)가 유효하다는 것을 보장한다.*__ 

### `*`와 `++`의 우선순위

```c
total += *start++;
```

`+`와 `++`는 우선순위는 같지만 오른쪽에서 왼쪽으로 결합한다. 즉, `++`가 `*start`가 아니라 `start`에 적용된다는 것을 의미한다. 이를 명시적으로 하기 위해서는 `*(start++)`과 같이 쓸 수 있고, `start`가 가리키는 메모리의 값을 변화시키고 싶다면 `(*start)++`와 같이 작성해야 한다.

### 포인터 연산

- __대입하기__ <br>
포인터에 주소를 대입할 수 있다.

```c
int ar[3] = {1, 2, 3};
int *p = ar;
int *p1 = &ar[2];

printf("p = %p", p);
```

> 000000000061FE0C

- __역참조__ <br>
`*`연산자를 이용하여 포인터가 가리키는 주소의 값을 얻을 수 있다.

```c
int ar[3] = {1, 2, 3};
int *p = ar;

printf("%d", *p);
```

> 1

- __주소 얻기__ <br>
`&`연산자를 이용하여 해당 변수(포인터도 포함)가 저장되어 있는 주소를 구할 수 있다.

```c
int ar[3] = {1, 2, 3};
int *p = ar;

printf("%p", &p);
```

> 000000000061FE08

- __포인터에 정수 더하기__ <br>
포인터에 정수를 더할 때, 포인터가 가리키는 데이터형의 바이트 수만큼 정수에 곱해져서 더한다.

```c
int ar[3] = {1, 2, 3};
int *p = ar;

printf("p + 3 = %p", p + 3);
```

> 000000000061FE18

- __포인터 증가시키기__ <br>
포인터를 증가시키면(`++`연산자), 포인터와 정수의 덧셈과 마찬가지로 포인터가 가리키는 데이터형의 바이트 수만큼 증가한다.

```c
int ar[3] = {1, 2, 3};
int *p = ar;

printf("p++ = %p", p++);
```

> 000000000061FE0C

- __포인터에서 정수 빼기__ <br>
포인터에 정수를 뺄 때, 덧셈과 마찬가지로 포인터가 가리키는 데이터형의 바이트 수만큼 정수에 곱해져서 뺀다.

```c
int ar[3] = {1, 2, 3};
int *p = &ar[2];

printf("p - 1 = %p", p - 1);
```

> 000000000061FE10

- __포인터 감소시키기__ <br>
포인터를 감소시키면(`--`연산자), 포인터 증가와 마찬가지로 포인터가 가리키는 데이터형의 바이트 수만큼 감소한다.

```c
int ar[3] = {1, 2, 3};
int *p = &ar[2];

printf("--p = %p", --p);
```

> 000000000061FE10

### 배열 내용 보호

C에서 배열을 함수의 매개변수로 넘겨줄 때, 대개는 배열을 clone하지 않고 원본 배열의 시작 주소를 그대로 넘겨준다. 이때 피호출함수에서 배열의 값들을 변경한다면, 원본 배열의 값도 변경되는 문제가 발생한다(프로그래머가 배열 값의 변경을 의도하지 않았을 때). __K&R C__ 에서 이러한 문제를 피하는 방법은 __그저 조심하는 것__ 이다. __ANSI C__ 에서는 한 가지 대안이 있다. 형식 매개변수를 선언할 때 `const` 키워드를 사용하는 것이다.

```c
#incldue <stdio.h>

int sum(const int ar[], int n);
...

int main(void)
{
    int arr[4] = {1, 2, 3, 4};
    // const의 위치를 유심히 보자
    const int *p1 = arr;
    int * const p2 = arr;
    const int * const p3 = arr;

    *p1 = 5;    // 허용되지 않음
    p1++;       // 허용
    *p2 = 6;    // 허용
    p2++;       // 허용되지 않음
    *p3 = 7;    // 허용
    p3++;       // 허용
}
...
```

`const`로 선언된 포인터를 피호출함수로 넘겨주면 피호출함수 body에서 배열의 값을 변경하려고 할 때 에러 메시지를 내보낸다. `const` 키워드의 위치 또한 중요하다. 
- `const`가 __data type__ 앞에 오면 포인터가 가리키는 주소의 값을 변경하는 건 허용되지 않고, 포인터가 가리키는 주소의 변경은 허용한다.
- `const`가 __name__ 앞에 오면 포인터가 가리키는 주소의 값을 변경하는 것은 허용되고, 포인터가 가리키는 주소의 변경은 허용되지 않는다.
- `const`가 __data type__ 앞, __name__ 앞에 모두 위치하면 포인터가 가리키는 주소의 값, 포인터가 가리키는 주소의 변경을 모두 허용하지 않는다.
<br><br>

또한, `const`로 선언된 포인터에는 `const`로 선언된 포인터나 `const`로 선언되지 않은 포인터 모두를 대입할 수 있다. 그러나, `const`로 선언되지 않은 포인터에는 `const`로 선언된 포인터를 대입할 수 없고, `const`로 선언되지 않은 포인터만 대입될 수 있다. __*이는 `const`키워드가 배열 요소의 변경을 막는 역할을 한다는 것을 생각하면 당연하다!*__ 위와 같은 제한이 없다면 일반 포인터로 `const`로 선언된 배열을 수정할 수 있기 때문이다. 