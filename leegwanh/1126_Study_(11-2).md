# 1126 C-Study
사용 도서 : C 기초 플러스 6판 (성안당)

###### Chapter 10. 배열과 포인터 (page 496 ~ 511)
###### Chapter 11. 문자열과 문자열 함수 (page 518 ~ 527)
<hr>

### 함수와 다차원 배열

```c
int arr[3][4];

void function1(int (* arr)[4], int rows);
void function2(int arr[][4], int rows);
```

arr를 함수로 넘겨주려면, 피호출함수는 arr와 형식이 맞는 형식 매개변수를 선언해야 한다. 위의 코드 같은 경우, arr는 __int형 4개짜리를 가리키는 포인터__ 이다. 위의 두 프로토타입은 모두 유효하다. 위 프로토타입이 암시하고 있는 것은, column은 고정되어 있지만(4), rows는 넘겨주는 인자에 따라 달라진다는 것이다. 또한, `function2`의 선언에서 첫번째 매개변수의 두번째 각괄호에 값(상수)을 넣어주지 않으면 잘못된 선언이다. *왜냐하면, `arr+1`과 같은 연산을 함수에서 실행할 때 __포인터가 가리키는 객체의 크기를 컴파일러가 알아야 하기 때문이다.__* 첫번째 각괄호에도 값이 들어갈 수 있지만, 이는 무시된다. __*즉, 다차원 배열을 함수로 넘겨주려면, 해당 함수에서는 배열의 형식과 맞는 매개변수를 잘 설정하고, `function2`와 같이 선언할 경우 첫번째 각괄호를 제외한 모든 각괄호에 값(상수)을 제공해야 한다.__*

### VLA

위의 예시를 다시 끌고오자.

```c
int arr[3][4];

void function1(int (* arr)[4], int rows);
void function2(int arr[][4], int rows);
```

C에서는 본래 배열의 차원에 상수만을 허용하였기 때문에, 위의 예시에서는, columns이 4가 아닌 다른 배열을 처리하려면 새로운 함수를 선언하고 정의해야 했다. 이를 극복하기 위해 어떤 크기의 2차원 배열에도 적용할 수 있는 함수를 만들려면 매우 복잡하다(책의 말을 그대로 빌리자면, 1차원 배열로 그 배열을 전달한 후, 각 행이 어디에서 시작하는지 함수가 계산해야 한단다). 이런 형식은 __FORTRAN__ (함수 호출에서 행과 열의 두 크기를 모두 지정하는 것을 허용)의 서브루틴과 잘 어울리지 못한다. __FORTRAN__ 의 형식과 잘 어울리지 못하는 것이 왜 문제가 되냐면, __*오늘날 C가 FORTRAN의 지위를 넘겨받고 있으므로, 적은 노력으로도 FORTRAN 라이브러리들을 변환할 수 있는 능력이 필요하기 때문이다*__ (라고 책에서는 말하지만, 아직 와닿지는 않는다).<br>
위와 같은 이유로, `C99`에서는 __VLA(Variable Length Array)__ 를 도입했다. 이제 배열의 크기를 지정할 때 변수를 사용할 수 있게 되었다. __VLA__ 에는 몇가지 제약이 있는데, 그것은 다음과 같다.
- __기억 부류 변경자__ 를 사용하지 않고, 함수 안, 또는 함수 매개변수로 선언해야 한다.
- __VLA__ 로 배열을 선언하면 선언 시 초기화할 수 없다.
<br><br>

__VLA__ 를 사용하여 선언한 배열을 함수로 넘겨주려면 피호출함수의 매개변수는 어떠한 형식을 취해야 할까?

```c
int function3(int rows, int columns, int arr[rows][columns]);   // 1
int function3(int arr[rows][columns], int rows, int columns);   // 2
int function3(int, int, int arr[*][*]);                         // 3
```

arr가 rows와 columns를 필요로 하기 때문에, __2__ 와 같은 선언은 잘못된 것이다. 또한, `C99`와 `C11`표준에서는 이름이 생략된 함수 프로토타입을 지원하는데, 이 경우에는 __3__ 번처럼 생략된 크기를 `*`로 표기해야 한다.

### compound literal

`C90` 또는 그 이전에 배열에는 정수 상수, 문자 상수 같은 배열 상수가 존재하지 않았다. 그것을 극복하기 위해 생겨난 개념이 __복합리터럴__ 이다. 복합리터럴은 비단 배열에만 사용하는 것이 아니라 구조체까지 포함한다.

```c
(int [2]){10, 20}      // 복합리터럴
(int []){10, 20}       // 크기 생략
```

위와 같은 복합리터럴은 상수이므로, 그 값을 즉시 사용하지 않으면 날아간다. 따라서 생성했을 때 즉시 사용해야 한다.

<hr>

## Chapter 11. 문자열과 문자열 함수

### 문자열 상수

문자열 상수는 __static storage class__ 에 저장된다. 지역변수와 함수 매개변수가 __stack__ 에 저장되는 것과는 다르다. 또한, `ANSI C`에서는 문자열리터럴들 사이에 아무것도 없거나 화이트스페이스만 있다면, 그 문자열리터럴들을 하나로 결합한다.

### 배열 vs 포인터

문자열을 선언할 때, 배열로 선언하는 것과 포인터로 선언하는 것에는 무슨 차이점이 있을까?
- `배열`로 선언한다면 __static memory__ 에 있는 문자열을 __stack(책에는 stack이라고 명시하지는 않았지만, 아마 스택일 것이다)__ 에 저장되어 있는 배열에 그대로 복사한다. 
- `배열`의 이름은 __address constant__ 이다. 따라서 배열의 이름에 다른 포인터 값을 할당하는 것이 허용되지 않는다. 배열 이름을 `arr`라 한다면, `arr+1`과 같은 연산은 가능하지만, `arr++`과 같은 증가연산자, 한마디로 `arr`의 값을 바꾸는 행위는 할 수 없다.
- `배열`을 사용하면 배열의 내용을 수정할 수 있다. `arr[2] = 'b'`은 배열의 세번째 원소의 값을 `'b'`로 바꾼다.

- `포인터`로 선언한다면, __메모리(stack)__ 에 포인터를 위한 공간을 할당하고, 그 포인터는 __static memory__ 에 저장되어 있는 문자열을 가리킨다. 
- `포인터`로 선언한 것은 __변수__ 이다. 따라서, 포인터 변수의 이름을 `p`라고 한다면, `p++`과 같은 연산이 가능하다. 
- `포인터`로 선언한 변수를 이용하여 배열의 내용을 바꿀 수 있을까? `*(arr + 1) = 'f'`와 같은 문장이 유효할까? __C 표준은 이와 같은 명령이 어떻게 될지 정의하지 않는다(Undefined behavior).__ 

<br>

추가적으로, 문자열리터럴은 상수이므로 포인터로 문자열리터럴을 가리킬 때는 `const`로 선언하는 것이 좋다. 포인터로 문자열리터럴의 값의 변경 가능 유무는 표준으로 정의되어 있지 않으므로, 이러한 코딩은 지양해야 한다. 따라서 `const`로 선언하는 것이 바람직하다. 