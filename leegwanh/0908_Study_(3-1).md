# 0908 C-Study
사용 도서 : C 기초 플러스 6판 (성안당)

###### Chapter 03. 데이터와 C (page 92 ~ 118)
###### Chapter 04. 문자열과 입출력 포맷 (page 118 ~ 121)
<hr>

### 문자의 출력
char형은 format specifier로 `%c`를 사용한다. 입출력 모두 동일하다. 그러나 문자 변수는 1바이트의 정수값으로 저장되기 때문에, `%d`로 char형을 출력하면 정수가 출력된다.
* char형의 부호?<br>
    몇몇 컴파일러들은 char형을 부호 있는 데이터형으로 취급하고, 몇몇은 그렇지 않다. `C90 표준`부터 char형에 signed와 unsigned를 사용하는 것을 허용했다. 이를 이용해 char형의 부호 여부를 명시적으로 표시할 수 있다.

### 이식 가능한 데이터형 : `stdint.h`와 `inttypes.h`
C는 다양한 정수형을 제공한다. 그러나 데이터형의 이름이 같더라도 시스템이 다르면 다른 것을 의미할 수도 있다. C언어가 시스템과 상관없이 동일한 의미를 가지는 데이터형을 사용하면 좋을텐데, 그것을 `C99 표준`에서 지원한다.
* __exact width type__<br>
    32비트 `int`형을 사용하는 시스템에서 `int32_t`형은 `int`와 동일한 32비트 `int`형을 나타낸다. 이 데이터형을 16비트 `int`, 32비트 `long`을 사용하는 시스템으로 옮겨보면, 사용하는 특정 시스템에 맞게 컴파일러가 `int32_t`형을 적절하게 대체한다(해당 시스템의 32비트 정수형 표현에 해당하는 데이터로 대체한다는 말).
* __minimum width type__<br>
    이는 시스템이 __*exact width type*__를 지원하지 않을 때 사용할 수 있다. 이 데이터 타입은 충분히 크면서도 최소의 크기를 가진 데이터형을 포함한다. 예를 들어보자. `int8_t`형은 가장 작은 데이터형이 16비트인 시스템에서는 사용할 수 없을 것이다. 그러나 8비트 부호 있는 정수값을 가질 수 있는 최소 데이터형인 `int_least8_t`는 사용할 수 있다. 해당 시스템에서는 16비트 정수로 표현될 것이다. 
* __fastest minimum width type__<br>
    속도에 신경을 쓰는 프로그래머를 위해 위 타입을 지원한다. `int_fast8_t`형은 8비트 부호 있는 정수를 가장 빠르게 계산할 수 있다.

### float형, double형, long double형
- __float형__ <br>
    최소한 `6자릿수 유효숫자`를 나타낸다. 최소 `10^(-37) ~ 10^37` 의 범위를 허용해야 한다. 대부분의 시스템들이 32비트로 저장하며, 8비트는 지수부, 24비트는 가수부에 쓰인다.
- __double형__ <br>
    `double`형은 최소한 `float`형만큼의 범위를 허용한다. `유효숫자의 최소 자릿수는 10`이다. 대개 64비트로 표현된다. 시스템에 따라 `float`형으로부터 추가된 32비트를 사용하는 방법이 다르다. 
- __long double형__ <br>
    `double`형보다 더 높은 정밀도를 제공한다. C언어는 `long double`형이 최소한 `double`만큼의 정밀도를 제공해야 한다고만 정의한다. 
<br>

기본적으로 컴파일러는 부동소수점형 상수들을 `double precision`으로 여긴다. 상수 `4.0`이나 `2.0`는 64비트의 `double`형으로 저장된다. 만약 `4.0 * 2.0`과 같은 수식을 `float`형 변수에 대입한다면, 64비트 `double`형의 상수를 32비트 `float`형 상수로 크기를 조정하여 저장한다. __*더 높은 정밀도를 허용하지만, 프로그램 실행 속도를 저하시킨다.*__ <br>
이를 피하려면 접미사로 f나 F, l이나 L를 사용하면 된다. f와 F는 `float`형으로, l과 L은 `long double`형으로 상수를 저장한다. <br>

### overflow와 underflow
* __overflow__<br>
    데이터형이 표현할 수 있는 최대 크기를 벗어났을 때 __*overflow*__가 발생한다. C는 무한대를 뜻하는 특별한 값이 해당 주소에 대입되고 출력 시 `inf` 또는 `infinity`로 출력한다고 규졍한다. 
* __underflow__<br>
    `float`형으로 표현할 수 있는 가장 작은 수가 어떤 변수에 저장되었다고 가정하자. 이 수를 2로 나눈다고 생각하자. 이것은 2의 보수 표현에서 지수를 1만큼 줄이는 행위이다. 그러나 지수는 이미 제일 작은 수를 나타내고 있으므로, 가수부에 있는 비트들을 오른쪽으로 한칸씩 옮겨 첫번째 자리를 비우고, 마지막 자릿수를 잃는다. 

### sizeof
`sizeof`로 데이터형의 크기를 알 수 있다. C언어에서 `char`형의 크기를 1바이트로 정의하기 때문에, `char`형은 항상 크기가 1바이트이다! 따라서 16비트 `char`형과 64비트 `double`형을 사용하는 시스템에서 sizeof로 `double`형의 크기를 출력해보면 __*4바이트*__ 가 나온다!

### 전달인자와 함정
`printf()`, `scanf()`같은 C 함수들은 전달인자의 개수를 정해놓지 않는다. 따라서 프로그래머가 `format specifier`의 개수와 `전달인자의 수`가 같은지, 그리고 `format specifier`와 `전달인자의 데이터형`이 같은지 확인해야 한다. 또한 C 컴파일러는 위와 같은 확인이 잘 이루어지지 않아 오류가 발생했을 때 경고 메시지를 출력하지만 프로그램 자체를 거부하지 않는다. 
> C언어의 철학을 느낄 수 있는 부분이다.

### buffer
`유닉스 프로그래밍` 수업에서 `buffer`에 관한 설명을 들은 기억이 있다. 예를 들어 한글 프로그램을 사용자가 작성할 때, 모든 수정사항을 실시간으로 보조기억장치에 저장하면 성능 저하의 원인이 될 수 있다. 따라서 `buffer`라는 중개 기억 공간(책에 나와있는 표현을 그대로 사용했다.)에 저장했다가, 일정한 시간 간격으로, 혹은 특별한 지시를 받았을 때 `buffer`의 내용을 한꺼번에 내보낸다. C언어에서는 `printf()`를 `buffer`에 저장하는데, `buffer`가 가득 찼을 때, 개행 문자를 만났을 때, 즉시 입력이 있을 때 `printf()`를 내보낸다. 즉, 이때서야 화면에 내용을 출력한다. __*`printf()`를 만날 때마다 화면에 출력하는 게 아니었구나?*__

>3장 마무리 멘트 : <br>
>C는 놀랄만큼 많은 수치 데이터형을 제공한다. 될 수 있는 한 프로그래머의 진로를 방해하지 말자는 C의 철학을 느낄 수 있다.