# 1112 C-Study
사용 도서 : C 기초 플러스 6판 (성안당)

###### Chapter 10. 배열과 포인터 (page 449 ~ 474)
<hr>

### 배열

__배열__ 은 동일한 데이터형을 가진 연속된 원소들의 집합이다. __배열__ 선언 시, 배열의 크기(몇 개의 원소를 가지는지)와 원소들의 데이터형이 무엇인지 컴파일러에게 알려야 한다. 이 정보를 가지고 컴파일러는 배열을 올바르게 설정한다. 

- __배열의 초기화__<br>
<p>

    __배열의 초기화__ 는 배열 선언 시에만 허용된다. 배열의 원소들은 `,`로 구분되며 `{}`로 묶인다. 다음 예시처럼 크기가 8인 배열에 7개의 원소만 넘겨준다면, 마지막 8번째 원소는 0으로 초기화된다. 그러나 배열의 크기보다 더 많은 원소를 넘겨주면 컴파일러는 이를 에러로 간주한다.

    ```c
    int main(void)
    {
        int powers[8] = {1, 2, 4, 8, 16, 32, 64};   // ANSI C와 그 이후
    }
    ```

    추가적으로, `C99`는 *designated initializer*를 도입했다. 

    ```c
    int arr[6] = {0, 0, 0, 0, 0, 212};      // old syntax
    int arr[6] = {[5] = 212};               // C99
    ```

    배열의 크기를 지정하지 않고 초기화를 진행한다면, 컴파일러는 초기화되는 값들을 수용할 수 있는 크기의 배열을 만든다. 
<p>

- __배열의 범위__<br>
C 프로그래머는 배열의 크기를 벗어난 값들을 참조하는 프로그램을 작성하지는 않았는지 항상 유념해야 한다. *왜냐하면 C 컴파일러는 이를 에러로 간주하지 않기 때문이다(간혹 경고 메시지를 출력하는 컴파일러도 있지만, 컴파일은 잘 된다).* 배열의 크기를 벗어난 값을 참조하면 프로그램의 다른 변수의 값을 변경하거나, 프로세스가 아예 종료될 수도 있다.<br>

>이러한 난처한 일을 C는 왜 허용했을까?<br>
>그 이유는, '프로그래머를 믿는 C의 철학' 때문이다. 배열의 범위를 검사하지 않음으로써 C는 더 빠른 실행속도를 보상으로 제공한다.<br>

- __배열의 크기 지정__<br>
    1. __C99 이전__<br>
        각괄호 안에 __constant integer expression__ 만 허용했다. 이는 정수 상수로만 이루어진 표현식을 뜻한다. `sizeof`도 여기에 속하지만, `const`는 포함되지 않는다. 또한, __variable-length array__ 를 지원하지 않는다.
    2. __C99 이후__<br>
        __VLA(variable-length array)__ 를 지원한다. __VLA__ 의 여러 제한사항들은 해당 chapter의 뒤에서 다시 설명한다고 한다.

- __다차원 배열__<br>
<p>
배열 이름 뒤에 각괄호가 여러 개 나오는 것이다. 

```c
float rain[5][12];
```

위와 같은 코드에서 `rain`은 크기가 5인 배열이다. `rain`의 각 원소들은 크기가 12인 배열이다. 

```c
int two_dim[2][3] = 
{
    {1, 2, 4},
    {3, 4, 5}
};
```

위 코드는 다차원 배열을 초기화하는 예시이다. 

```c
// 1.
int sq[2][3] = 
{
    {5, 6},
    {7, 8}
};

// 2.
int sq[2][3] = {5, 6, 7, 8};
```

__1번__ 은 첫번째 행에 __5, 6, 0__ , 두번째 행에 __7, 8, 0__ 이 대입된다. __2번__ 은 첫번째 행에 __5, 6, 7__ , 두번째 행에 __8, 0, 0__ 이 대입된다. 
<p>


### 포인터와 배열

배열의 이름은 배열의 첫번째 원소의 주소를 의미한다. __*결론부터 말하자면, 배열 표기는 포인터의 변장된 사용에 불과하다!*__ <br>
포인터에 1을 더할 때, C는 하나의 __기억단위(storage unit)__ 를 더한다. 즉, `int`형 배열의 이름인 __arr_name__ 의 경우 포인터에 1을 더하면 __(arr_name + 1)__ , __arr_name + 1__ 의 주소는 __arr_name__ 과 비교했을 때 __4__ 만큼 더 크다. 이는 __arr_name__ 이 `int`형 배열의 이름이기 때문이다(`int`형의 크기는 주로 4바이트이고, 시스템마다 차이가 있을 수 있다). __*이것이 포인터가 가리키는 객체의 데이터형을 선언해야 하는 이유이다.*__

```c
#define SIZE 4

int main(void)
{
    int ar[SIZE] = {1, 2, 3, 4};

    *(ar + 3) == ar[3];     // true
    ar + 2 == &ar[2];       // true
}
```

이제 위 코드를 음미해보자.`ar`은 배열의 첫번째 원소를 가리키는 주소이다. 따라서 __ar + 3__ 은 그 주소에서 3을 더한 값이다. 그 주소에 저장되어 있는 값은 __ar[3]__ 과 동일하다. 즉, C에서는 *ar[n]이 *(ar + n)을 의미하도록 정의한다!* 이 때문에, __n[ar] = *(ar + n) = ar[n]__ 또한 성립한다.

### 함수 인자로 배열 넘겨주기

함수 인자로 배열을 넘겨줄 때, 배열의 시작 주소만 넘겨주고 배열의 크기에 대한 정보는 넘겨주지 않는다. *따라서 별도의 인자로 배열이 크기를 넘겨주거나, 함수 body 내에서 배열의 크기를 임의로 정하여 코딩하는 방법이 있다.* <br><br>
배열의 이름은 첫번째 원소의 주소이기 때문에, 배열 이름을 전달인자로 사용하면 대응하는 형식매개변수는 포인터가 되어야 한다. __오직 이 상황에서만__ , __int ar[]__ 와 __int *ar__ 를 같은 의미로 해석한다(ar이 `int`형을 가리키는 포인터형). 따라서 다음 네 개의 프로토타입은 동등하다.

```c
int sum(int *ar, int n);
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);
```

함수 내에서 정의된 배열의 크기를 `sizeof`로 출력한다면, __데이터형의 크기(byte) x 배열의 크기__ 를 출력한다. 그러나, 인자로 넘겨받은 배열(포인터)를 `sizeof`로 출력한다면, 대부분의 시스템에서 __8바이트__ 를 출력할 것이다(시스템에 따라 다르다).<br>