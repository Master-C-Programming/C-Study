# 1105 C-Study
사용 도서 : C 기초 플러스 6판 (성안당)

###### Chapter 09. 함수 (page 393 ~ 420)
<hr>

### 함수

- __function prototype__<br>
함수의 선언. 함수 선언 뒤에는 `;`이 붙는다. 해당 함수를 사용하기 전 선언해야 한다. 그러나 __function definition__ 이 해당 함수를 호출하는 *호출함수* 보다 먼저 나오면 __function prototype__ 을 사용하지 않아도 된다.<br>
__ANSI PROTOTYPE__ 은 *반환값의 데이터형*과 *전달인자의 데이터형*을 명시해야 한다.
__ANSI 이전__ 에는 *전달인자의 데이터형*을 명시하지 않았다. 이는 함수가 호출 시 전달인자의 데이터형 또는 개수를 잘못 명시할 때 에러를 검출하지 못하는 문제를 야기한다. <br>
__함수 선언__ 은, 컴파일러에게 함수에 대한 정보를 미리 알리는 것이며, 후에 컴파일러가 해당 함수의 함수 호출을 어떻게 처리할 것인지를 결정할 때 도움을 준다.

```c
void show_n_char(char ch, int num);     // ANSI Prototype
void show_n_char(char, int);            // 허용
void show_n_char();                     // ANSI C 이전 형식. 표준에서 탈락할 가능성 높음
```

- __function call__<br>
함수 호출. 정의한 함수를 사용하는 부분이다. 함수의 *파라미터*가 정의되어 있으면 *전달인자*를 넘겨주면서 함수를 호출한다. 피호출함수가 `return`되면 프로그램의 흐름은 호출함수의 다음 라인으로 넘어간다. 

```c
int max = max(x, y, z);                 // function call
printf("max of x, y, z : %d", max);     // max함수 리턴 후 프로그램 위치
```

- __function definition__<br>
함수의 정의. 구체적인 함수의 `body`를 정의하는 부분이다. 함수 선언과 달리 끝에 `;`이 붙지 않는다. 함수 정의는 다음과 같은 __ANSI C 함수 헤더__ 로부터 시작된다.

```c
void show_n_char(char ch, int num)      // ANSI C function header
void max(int x, int y, int z)           // ANSI C function header
void max(int x, y, z)                   // 에러
```

-  __함수 내 지역변수__<br>
함수 안에서 정의되는 변수와 *파라미터*는 지역변수로 선언된다. 즉, 해당 함수가 `return`되면 폐기되고, 같은 이름을 다른 함수에서 사용해도 무관하다. 이러한 이름이 같은 변수들은 실제로 다른 메모리 영역을 나타낸다. 

- __actual argument__ vs __formal parameter__<br>
__formal parameter__ 는 피호출함수에 있는 변수이다. __actual argument__ 는 호출함수에 의해 피호출함수의 __formal parameter__ 로 대입되는 값이다.

- __함수 내 `return`위치에 대한 고찰__<br>
유지보수 면에서, 프로그램의 실행흐름을 따라가기에는 함수의 마지막에만 `return`이 있는 것이 좋을 것 같다. 그러나 길이가 짧은 함수에서까지 그럴 필요는 없을 듯하다.

- __함수의 데이터형__<br>
함수도 데이터형으로 선언해야 한다. 리턴값이 있는 함수는 리턴값의 데이터형과 같은 형으로 선언해야 한다. 리턴값이 없으면 `void`로 선언해야 한다. *구형 C컴파일러들은 데이터형이 정의되지 않은 함수들의 데이터형을 `int`라고 가정했다. 그러나 이러한 관행을 `C99`표준에서는 지원하지 않는다.* 이러한 관행이 생겨난 이유는, 초창기 C 함수의 대부분이 `int`형이었기 때문이다. 

- __함수 선언__ vs __함수 정의__<br>
__함수 선언__ 은 컴파일러에게 그 함수가 어떤 데이터형인지 알려주는 것이다. __함수 정의__ 는 그 함수의 실제 코드를 제공하는 것이다. 예시로, `#include`지시자로 `math.h`헤더를 포함하는 것은 `sqrt()`가 `double`형을 리턴한다고 컴파일러에게 알려준다. 그러나 `sqrt()`의 실제 코드는 라이브러리에 존재한다. 라이브러리에 존재하는 실제 코드를 오브젝트파일과 연결한 후 실행파일을 만드는 역할을 __*링커*__ 가 한다.

- __전달인자가 없는 경우__ vs __지정되지 않은 전달인자__

```c
void print_name();          // 1
void print_name(void);      // 2
```

__1번__ 과 같이 선언하면, ANSI C 컴파일러는 프로그래머가 함수 프로토타입(__1번__ 에서 전달인자의 데이터형까지 정의하는 것)없이 코딩을 한다고 가정하고 *전달인자들을 검사하지 않는다.*<br>
__2번__ 은 컴파일러가 해당 함수 호출 때 *정말 전달인자를 사용하지 않는지 검사한다.*