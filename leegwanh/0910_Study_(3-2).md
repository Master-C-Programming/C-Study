# 0910 C-Study
사용 도서 : C 기초 플러스 6판 (성안당)

###### Chapter 04. 문자열과 입출력 포맷 (page 121 ~ 148)
<hr>

### 문자열
C는 문자열을 위한 특별한 데이터형을 제공하지 않는다. 대신 `char`형 배열에 문자열을 저장한다. `\0`이라는 `널 문자`는 문자열 마지막에 자동으로 저장된다(프로그래머가 직접 입력하지 않는다는 의미). `\0`은 문자열의 끝을 의미한다. `scanf()`로 배열을 입력받을 때, 사용자가 `\0`문자를 입력할 필요는 없고, 이때는 `scanf()`가 그 작업을 수행한다. 그러나 `#define`과 같은 전처리기 지시자로 정의된 상수는 `컴파일러`가 `널 문자`를 넣는다. 
* __`scanf()`가 입력을 받는 방식__<br>
    `scanf()`는 입력을 받다가 첫 `whitespace`를 만나면 읽기를 멈춘다. 따라서 문자열을 입력할 때 띄어쓰기가 포함된 문장을 입력한다면, 맨앞에 있는 한 단어만 `scanf()`가 읽는다.
* __`strlen()`함수__<br>
    `strlen()`함수는 문자열의 크기를 문자 수로 알아낸다. `\0`은 `strlen()`에게 언제 카운트를 멈춰야 하는지 알려준다. `strlen()`는 정확한 문자의 개수를 알려주지만, `sizeof`연산자는 `\0`문자까지 카운트하기 때문에, `strlen()`으로 얻은 값보다 __*1*__ 크다.

### 상수와 C 전처리기
C는 상수를 정의하는 다양한 방법을 제공한다. 그중 하나가 __*C 전처리기*__ 를 이용하는 것이다. 다음의 예시를 보자.

```c
#define PI 3.141592
```

프로그램이 컴파일 될 때, `PI`가 사용된 모든 곳은 `3.141592`로 변경된다. 이것을 __*compile-time substitution*__ 이라 한다. 흔히 이렇게 정의된 상수를 __*manifest constant*__ 라고 한다.
>상수의 이름은 대문자로 표기하는 것이 C의 현명한 전통이다.

### printf()와 scanf()
이들은 입출력 함수이다. 줄여서 __I/O 함수__ 라고 부른다. C 라이브러리에 있는 다른 함수들과 마찬가지로, 이 함수들도 C에 정의된 부분이 아니었다. 
>본래부터 C는 입출력에 대한 구현을 컴파일러 개발자에게 위임했다.<br>
>그렇게 함으로써 특정 시스템마다 더 좋은 I/O를 갖출 수 있었다.<br>
>그러나 여러 버전들이 등장하면서 컴파일러 사이에 불일치가 발생했다.<br>
>그래서 C90과 C99표준은 이 입출력 함수들에 대한 표준을 정했다.<br>

### printf() 함수

##### printf()의 기본 형식

```c
printf(Control-string, item1, item2,...);
```

`printf()`는 각 변수마다 적절한 출력을 제공하기 위해 여러 __*conversion specifier*__ 를 제공한다. 

* __Control-string__<br>
    `item1`, `item2`는 출력할 항목들이다. `Control-string`은 이러한 항목들을 어떤 포맷으로 출력할 것인지를 지정하는 __문자열__ 이다.
* __float형 전달인자의 변환__<br>
    C에는 `float`형을 위한 변환 지정자는 따로 없다. 그 이유는 __*K&R C*__ 이후로 `float`형 값은 표현식에서 사용되거나 전달인자로 사용되기 전에 `double`형으로 자동 변환되었다. `ANSI C`이후로는 그러한 자동 변환을 실시하지 않는다. 그러나 기존의 방식으로 코딩된 프로그램들을 보호하기 위해 `printf()`에 전달되는 `float`형 전달인자들은 여전히 자동으로 `double`형으로 변환된다. 
    - __float형의 default 출력__<br>
        * __%f__<br>
            1. `필드 너비` : 그 수를 넣을 수 있을 만큼
            2. `소수점 아래 자릿수` : 6자리
        * __%e__<br>
            소수점 위에 1개의 숫자 출력, 소수점 아래 6개 숫자 출력
* __conversion speficier__<br>
    `conversion speficier`는 컴퓨터에 2진수 포맷으로 저장되어 있는 값을 출력할 연속된 문자들로 변환한다. 이때 반드시 출력할 데이터형과 `conversion speficier`가 잘 대응되어야 한다.
* __conversion speficier 오용으로 인한 에러__<br>

```c
    float n1 = 3.0;
    double n2 = 3.0;
    long n3 = 2000000000;
    long n4 = 1234567890;

    printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);
```

>output<br>
>0 1074266112 0 1074266112

위 코드 `printf()`함수는 변수 `n1`, `n2`, `n3`, `n4`의 값을 컴퓨터에 넘겨주라고 지시한다. 컴퓨터는 이 값들을 `stack`에 넣는다. 이때 __`conversion specifier`의 안내를 받는 것이 아니라 변수들의 데이터형의 안내를 받는다!__ 따라서 `n1`은 8바이트(`float`형은 `double`형으로 변경), `n2`도 8바이트, `n3`, `n4`는 각각 4바이트를 차지한다. __그 후 제어가 `printf()`로 넘어간다.__ 이제 `printf()`는 `conversion specifier`의 안내를 받는데, `%ld`지정자는 4바이트를 읽으라고 지시한다. 이것은 `n1`의 앞부분 절반이다. 이것을 `long int`형으로 해석하고, 이와 마찬가지로 그 다음 `%ld`는 `n1`의 뒷부분 절반을 `long int`형으로 읽는다. 그 후 세번째, 네번째 `%ld`지정자도 각각 `n2`의 앞부분 절반, 뒷부분 절반을 읽고 `long int`형으로 해석한다. 

>따라서 잘못된 conversion specifier를 하나라도 사용하면 나머지 올바른 지정자들도 엉터리 결과를 출력할 수 있다!