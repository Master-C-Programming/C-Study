1110 study<br><br>

## 분할정복 알고리즘
<hr>

**`분할정복(divide and conquer)`** 이란 큰 문제를 작은 문제들로 나누고(divide) 각각의 작은 문제들을 해결함으로써 큰문제를 해결하여 정복(conquer)하는 방법이다. 여기서 작은문제에서 바로 해를 구할 수있다면 더이상 더 작은문제들로 나눌 필요가 없지만 그렇지않다면 더 작은 문제들로 나눠 해를 구한다. 
<br>

분할정복은 문제를 나눔으로써 어려운 문제를 쉽게 해결 할 수잇다는 장점이 있다. 문제를 나누어 해결하는 분할정복의 특징상 병렬적으로 해결할 수있는데에 특히 큰 장점을 가진다.
하지만 분할정복의 정의를 읽어보면 알 수 있듯이 함수를 재귀적으로 호출하기 때문에 오버헤드가 크며 재귀호출이 많이 일어나다보면 오버플로우나 과도하게 메모리를 차지할 수 도 있다. 
<br>

조건부 컴파일에 사용되는 전처리기 지시자는 `#if` `#elif` `#else` `#endif` `ifdef` `ifnedf` 등이 있다.
<hr>

### 분할정복 문제 풀어보기 
<br>

* baekjoon 2630 색종이 만들기

**문제**

아래 <그림 1>과 같이 여러개의 정사각형칸들로 이루어진 정사각형 모양의 종이가 주어져 있고, 각 정사각형들은 하얀색으로 칠해져 있거나 파란색으로 칠해져 있다. 주어진 종이를 일정한 규칙에 따라 잘라서 다양한 크기를 가진 정사각형 모양의 하얀색 또는 파란색 색종이를 만들려고 한다.
전체 종이의 크기가 N×N(N=2k, k는 1 이상 7 이하의 자연수) 이라면 종이를 자르는 규칙은 다음과 같다.

전체 종이가 모두 같은 색으로 칠해져 있지 않으면 가로와 세로로 중간 부분을 잘라서 똑같은 크기의 네 개의 N/2 × N/2색종이로 나눈다. 나누어진 종이 I, II, III, IV 각각에 대해서도 앞에서와 마찬가지로 모두 같은 색으로 칠해져 있지 않으면 같은 방법으로 똑같은 크기의 네 개의 색종이로 나눈다. 이와 같은 과정을 잘라진 종이가 모두 하얀색 또는 모두 파란색으로 칠해져 있거나, 하나의 정사각형 칸이 되어 더 이상 자를 수 없을 때까지 반복한다.

입력으로 주어진 종이의 한 변의 길이 N과 각 정사각형칸의 색(하얀색 또는 파란색)이 주어질 때 잘라진 하얀색 색종이와 파란색 색종이의 개수를 구하는 프로그램을 작성하시오.

**입력**

첫째 줄에는 전체 종이의 한 변의 길이 N이 주어져 있다. N은 2, 4, 8, 16, 32, 64, 128 중 하나이다. 색종이의 각 가로줄의 정사각형칸들의 색이 윗줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다. 하얀색으로 칠해진 칸은 0, 파란색으로 칠해진 칸은 1로 주어지며, 각 숫자 사이에는 빈칸이 하나씩 있다.


```c
#include<stdio.h>

int blue = 0;
int white = 0;
int Is_same_color(int** Square, int row, int col, int length)
{
    for (int i = row; i < row+length; i++)
    {
        for (int j = col; j < col+length; j++)
        {
            if (Square[row][col] != Square[i][j])
            {
                Is_same_color(Square, row, col, length / 2);
                Is_same_color(Square, row, col+length / 2, length / 2);
                Is_same_color(Square, row+length / 2, col, length / 2);
                Is_same_color(Square, row+length / 2, col+length / 2, length / 2);
                return 0;
            }
        }
     }

    if (Square[row][col] == 1)
        blue++;
    else
        white++;
     return 0;
    
 }


int main()
{
    int N = 0;
    scanf("%d",&N);
    int** Square = malloc(sizeof(int*)*N);
    for (int i = 0; i < N; i++)
    {
        Square[i] = malloc(sizeof(int)*N);
    }
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
           scanf("%d",&Squarep[i][j]);
        }
    }
    Is_same_color(Square, 0, 0, N);
    printf("%d\n%d",white,blue);
}
}
```
**풀이**

이 문제를 한번에 푸는 것은 쉽지않다. 전체 정사각형의 색이 같은지 확인하고, 그것이 아니라면 길이를 나눠서 for문을 통해 또다시 색을 비교하는 작업은 복잡할 뿐만 아니라 시간도 상당히 오래 걸릴 것이다. 따라서 분할정복을 통해 작은문제로 나누어서 해결하는 것이 바람직하다. `Is_same_color`함수를 보면 색종이의 색이 다를 경우 색종이를 나누어 다시 함수를 호출하는 재귀적 방식을 사용하고 있다. 이렇게 하면 나눈 색종이의 색이 모두 같을 때까지 작은 문제로 나눈 후, 해를 구할 수 있다.
<hr>

### 분할정복 응용

분할정복을 사용하는 알고리즘들이 있다. **`병합 정렬(merge sort)`** 와 **`이분 탐색(bimary search)`** 등 많지만 이 두가지에 대해서 간단히 알아보자.

##### 병합정렬(merge sort)

병합정렬은 정렬할 데이터의 집합의 크기가 1 또는 0이 될때 까지 데이터 집합을 반으로 나눈 후 다시 데이터집합 들을 병합하여 하나의 데이터집합으로 만드는 정렬방식이다. 단, 병합할 때 데이터 집합의 원소는 순서대로 정렬된다.
<br>

예를 들어 {7,2,5,9,6,4,1,3,8}이라는 데이터 집합을 병합정렬 한다고 할 때 
>{7,2,5,9,6},{4,1,3,8}<br>
>{7,2,5},{9,6},{4,1},{3,8}<br>
>...<br>
>{7}{2}{5}{9}{6}{4}{1}{3}{8}<br>

이렇게 데이터들을 나눈후 병합해가며 정렬하는 과정이다. 병합하는 과정은 다음과 같다.
>{2,5,7},{6,9}을 병합한다고 가정할 때 <br>
>{ , , , , } 두개의 데이터 집합의 크기의 합만큼 데이터집합을 만들고<br>
>{2, , , , }2과6를 비교, 작은것을 새로 만든 집합에 넣는다.<br>
> {2,5 , , , }5과6을 비교, 작은것을 새로 만든 집합에 넣는다.<br>
> ... <br>
>{2,5,6,7,9} 의 정렬된 집합을 얻을 수 있다.<br>

###### 이분탐색(binary search)

이분탐색(binary search)는 검색할 자료를 반씩 나누어 나머지 반만 검색하는 방식을 반복하여 자료를 찾는 방법이다. 이를 이용하면 순차적으로 탐색하는 것보다 훨씬 빠른 속도로 자료를 찾을 수 있다.<br>
{2,3,5,6,7,9,10,12,13,15}의 데이터 집합에서 이분탐색을 통해 6을 찾는 과정은 다음과 같다.
>{2,3,5,6,7(mid),9,10,12,13,15}<br>
>{2,3(mid),5,6,}<br>
>{5(mid),6}<br>
>{6(key value)}<br>

<hr>