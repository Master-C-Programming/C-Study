0922 study<br><br>

## 그리디 알고리즘
<hr>

### 그리디 알고리즘(Greedy Algorytm)이란?
<br>

**`그리디 알고리즘`** 이란 문제를 해결하는 과정에서 그 순간순간 마다 최적이라고 생각되는 결정을 하는 방식으로 진행하여 최종 해답에 도달하는 문제 해결 방식이다.<br>
순간순간의 최적의 결정은 언제나 전체 결과에서의 최선의 해결책이 되는 것은 아니다. 하지만 이러한 단점을 극복하는 **`그리디 알고리즘`** 의 가장 큰 장점은 계산속도가 빠르다는 것이다. 따라서 **`그리디 알고리즘`** 적용되는 문제에서는 최적해를 빠르게 구할 수 있다. <br><hr>
아래의 문제는 **`그리디 알고리즘`** 의 대표적 예제인 동전문제이다.

* __문제__ 
준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.
동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.

* __입력__ 
첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)
둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)

* __출력__
첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.


```c
#include<stdio.h>
#include<stdlib.h>

int main()
{
    int N = 0;
    int K = 0;
    scanf("%d %d", &N, &K);

    int* number = malloc(sizeof(int) * N);
    for (int i = 0; i < N; i++)
    {
        scanf("%d", &number[N - i - 1]);
    }
    int cnt = 0;
    for (int i = 0; i < N; i++)
    {
        if (number[i] <= K)
        {
            cnt = cnt+ K / number[i];
            K = K % number[i];
        }
    }
    printf("%d", cnt);
    free(number);
    return 0;

}
```
* **풀이**
 K원을 만들기위한 최소 동전 개수를 구하는 문제이다. 그리디 알고리즘을 적용하면 첫번째 최적의 결정은 가장 가치가 큰 동전으로 K원에 가장 근접한 값을 만드는 것이다. 그다음 최적의 선택은 두번째로 가치가 큰 동전으로 남은 값에 가장 근접한 값을 만들고 그다음은 세번째 가치가 큰동전을 선택한다.  이런식으로 진행하다보면 동전의 개수가 최소인 결과를 얻게된다. 

<hr>

다음 예제는 회의실을 가장 효율적으로 쓰는 방법을 찾는 문제이다.

* __문제__ 
한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

* __입력__ 
첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.

* __출력__
첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.


```c
struct time
{
    int start;
    int end;
};

int main()
{
    int N = 0;
    int cnt = 1;
    int point = 0;
    struct time tmp;
    scanf("%d", &N);
    struct time* t = malloc((N + 1) * sizeof(struct time));

    for (int i = 0; i < N; i++)
    {
        scanf("%d %d", &t[i].start, &t[i].end);
    }i
    for (int i = 0; i < N - 1; i++)
    {
        for (int j = i + 1; j < N; j++)
        {
            if (t[i].end > t[j].end)
            {
                tmp.start = t[i].start;
                t[i].start = t[j].start;
                t[j].start = tmp.start;
                tmp.end = t[i].end;
                t[i].end = t[j].end;
                t[j].end = tmp.end;
            }
            else if (t[i].end == t[j].end)
            {
                if (t[i].start > t[j].start)
                {
                    tmp.start = t[i].start;
                    t[i].start = t[j].start;
                    t[j].start = tmp.start;
                }
            }
        }

    }
    tmp.end = t[0].end;
    tmp.start = t[0].start;

    for (int i = 0; i < N; i++)
    {
        if (t[i].start > tmp.end)
        {
            cnt++;
            tmp.end = t[i].end;
        }
    }
    printf("%d", cnt);
    free(t);
}
```
* **풀이**
회의실을 가장 효율적으로 쓰는 방법을 찾기위해 그리디 알고리즘을 적용하면 첫번째 최적의 결정은 가장먼저 끝나는 회의(A)를 찾는 것이다. 그다음으로 A가 끝나는 시간과 가장 가까운 시작시간을 가진회의(B)를 고르고 또 B가 끝나는 시간과 가장 가까운 시작시간을 가진 회의(C)를 구한다.
이런식으로 회의를 고르다보면 가장 효율적으로 회의실을 쓸 수있는 회의의 수가 나온다.<br>